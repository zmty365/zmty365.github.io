<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Namespace | 爱吃芝麻汤圆</title><meta name="author" content="爱吃芝麻汤圆"><meta name="copyright" content="爱吃芝麻汤圆"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#fafafa"><meta name="description" content="Linux 命名空间 在本小节，我们将了解容器的底层原理之一——Namespace，通过动手实践逐步搭建一个隔离的环境。  命名空间概述命名空间是一项 Linux 内核功能，于 2002 年随 Linux 2.4.19 引入。命名空间背后的想法是将特定的全局系统资源包装在抽象层中。内核命名空间抽象，允许不同的进程组具有不同的系统视图。这使得命名空间内的进程看起来拥有自己的全局资源的隔离实例。 从">
<meta property="og:type" content="article">
<meta property="og:title" content="Namespace">
<meta property="og:url" content="http://zmty365.github.io/posts/1000101/index.html">
<meta property="og:site_name" content="爱吃芝麻汤圆">
<meta property="og:description" content="Linux 命名空间 在本小节，我们将了解容器的底层原理之一——Namespace，通过动手实践逐步搭建一个隔离的环境。  命名空间概述命名空间是一项 Linux 内核功能，于 2002 年随 Linux 2.4.19 引入。命名空间背后的想法是将特定的全局系统资源包装在抽象层中。内核命名空间抽象，允许不同的进程组具有不同的系统视图。这使得命名空间内的进程看起来拥有自己的全局资源的隔离实例。 从">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zmty365.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-08-21T03:52:48.000Z">
<meta property="article:modified_time" content="2025-08-21T04:33:18.559Z">
<meta property="article:author" content="爱吃芝麻汤圆">
<meta property="article:tag" content="Container">
<meta property="article:tag" content="Namespace">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zmty365.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Namespace",
  "url": "http://zmty365.github.io/posts/1000101/",
  "image": "http://zmty365.github.io/img/avatar.jpg",
  "datePublished": "2025-08-21T03:52:48.000Z",
  "dateModified": "2025-08-21T04:33:18.559Z",
  "author": [
    {
      "@type": "Person",
      "name": "爱吃芝麻汤圆",
      "url": "https://github.com/zmty365"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zmty365.github.io/posts/1000101/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Chewy&amp;family=Ma+Shan+Zheng&amp;family=Fredoka+One&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Namespace',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/life-heatmap/"><span> 生命</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avatar.jpg" alt="Logo"><span class="site-name">爱吃芝麻汤圆</span></a><a class="nav-page-title" href="/"><span class="site-name">Namespace</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/life-heatmap/"><span> 生命</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Namespace</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-08-21T03:52:48.000Z" title="发表于 2025-08-21 11:52:48">2025-08-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">容器底层实现</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Linux-命名空间"><a href="#Linux-命名空间" class="headerlink" title="Linux 命名空间"></a>Linux 命名空间</h1><blockquote>
<p>在本小节，我们将了解容器的底层原理之一——Namespace，通过动手实践逐步搭建一个隔离的环境。</p>
</blockquote>
<h2 id="命名空间概述"><a href="#命名空间概述" class="headerlink" title="命名空间概述"></a>命名空间概述</h2><p><strong>命名空间</strong>是一项 Linux 内核功能，于 2002 年随 Linux 2.4.19 引入。命名空间背后的想法是将特定的全局系统资源包装在抽象层中。内核命名空间抽象，允许不同的进程组具有不同的系统视图。这使得<strong>命名空间内的进程看起来拥有自己的全局资源的隔离实例</strong>。</p>
<p>从 Linux 内核 5.6 开始，共有 8 种命名空间，每种负责隔离一种特定的系统资源。下表详细说明：</p>
<table>
<thead>
<tr>
<th>命名空间类型</th>
<th>对应的 <code>clone()</code> 标志</th>
<th>对应的 <code>unshare</code> 选项</th>
<th>作用（隔离的资源）</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PID</strong>（进程 ID）</td>
<td><code>CLONE_NEWPID</code></td>
<td><code>-p</code> 或 <code>--pid</code></td>
<td>隔离进程 ID 编号空间。每个命名空间内的进程有独立的 PID 序列（如各自的 PID&#x3D;1），且看不到其他命名空间的进程。</td>
<td>容器内的进程 PID 与主机隔离（如容器内的 <code>init</code> 进程为 PID&#x3D;1）。</td>
</tr>
<tr>
<td><strong>Mount</strong>（挂载）</td>
<td><code>CLONE_NEWNS</code></td>
<td><code>-m</code> 或 <code>--mount</code></td>
<td>隔离文件系统挂载点。不同命名空间的进程看到的挂载点（文件系统结构）可以不同。</td>
<td>容器拥有独立的根文件系统（如 <code>/</code> 目录与主机不同）。</td>
</tr>
<tr>
<td><strong>UTS</strong>（主机名&#x2F;域名）</td>
<td><code>CLONE_NEWUTS</code></td>
<td><code>-u</code> 或 <code>--uts</code></td>
<td>隔离主机名和域名。每个命名空间可以设置独立的 <code>hostname</code>。</td>
<td>容器可以有自己的主机名（如 <code>docker run --hostname mycontainer</code>）。</td>
</tr>
<tr>
<td><strong>IPC</strong>（进程间通信）</td>
<td><code>CLONE_NEWIPC</code></td>
<td><code>-i</code> 或 <code>--ipc</code></td>
<td>隔离 System V IPC 和 POSIX 消息队列。不同命名空间的进程无法通过 IPC 直接通信。</td>
<td>避免容器内进程与主机或其他容器的 IPC 冲突。</td>
</tr>
<tr>
<td><strong>Network</strong>（网络）</td>
<td><code>CLONE_NEWNET</code></td>
<td><code>-n</code> 或 <code>--net</code></td>
<td>隔离网络资源（网卡、IP、端口、路由表、防火墙规则等）。每个命名空间有独立的网络栈。</td>
<td>容器有独立的虚拟网卡和 IP（如 Docker 的桥接网络）。</td>
</tr>
<tr>
<td><strong>User</strong>（用户&#x2F;组 ID）</td>
<td><code>CLONE_NEWUSER</code></td>
<td><code>-U</code> 或 <code>--user</code></td>
<td>隔离用户 ID（UID）和组 ID（GID）。命名空间内的 UID&#x2F;GID 可以与外部不同（如容器内的 root 对应主机的普通用户）。</td>
<td>容器内的 root 用户在主机上无特权，提高安全性。</td>
</tr>
<tr>
<td><strong>Cgroup</strong>（控制组）</td>
<td><code>CLONE_NEWCGROUP</code></td>
<td><code>-c</code> 或 <code>--cgroup</code></td>
<td>隔离 cgroup 视图。进程只能看到自己所在的 cgroup 层级，无法访问其他命名空间的 cgroup 资源。</td>
<td>限制容器对系统资源（CPU、内存）的使用范围。</td>
</tr>
<tr>
<td><strong>Time</strong>（时间）</td>
<td><code>CLONE_NEWTIME</code></td>
<td><code>--time</code></td>
<td>隔离系统时间（包括时钟和计时器）。可以在命名空间内修改时间而不影响主机。</td>
<td>测试依赖时间的程序（如日志、证书过期）时，避免影响主机时间。</td>
</tr>
</tbody></table>
<h2 id="命名空间相关API"><a href="#命名空间相关API" class="headerlink" title="命名空间相关API"></a>命名空间相关API</h2><h3 id="1-clone-：创建新进程时“顺带”创建新命名空间"><a href="#1-clone-：创建新进程时“顺带”创建新命名空间" class="headerlink" title="1. clone()：创建新进程时“顺带”创建新命名空间"></a>1. <code>clone()</code>：创建新进程时“顺带”创建新命名空间</h3><p><code>clone()</code> 是最“主动”的一个——它的核心功能是<strong>创建一个新进程</strong>，但可以在创建时为这个新进程<strong>单独创建一个或多个命名空间</strong>，让新进程“活”在这些新命名空间里，与父进程的命名空间隔离。</p>
<h4 id="关键特点："><a href="#关键特点：" class="headerlink" title="关键特点："></a>关键特点：</h4><ul>
<li><strong>必须创建新进程</strong>：<code>clone()</code> 本质是进程创建函数（类似 <code>fork()</code>，但更灵活）；</li>
<li><strong>新命名空间是“全新的”</strong>：新进程会进入这些新创建的命名空间，而父进程仍在原来的命名空间中；</li>
<li><strong>通过标志指定命名空间类型</strong>：需要传递命名空间相关的标志（如 <code>CLONE_NEWNS</code> 对应挂载命名空间，<code>CLONE_NEWPID</code> 对应 PID 命名空间等），每个标志对应一种命名空间。</li>
</ul>
<h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p>假设父进程在“默认命名空间”中，现在用 <code>clone()</code> 创建子进程，并指定 <code>CLONE_NEWPID</code> 标志（创建新的 PID 命名空间）：</p>
<ol>
<li>子进程被创建，同时内核为它新建一个 PID 命名空间；</li>
<li>子进程在这个新的 PID 命名空间中，它的 PID 会被分配为 1（因为每个 PID 命名空间的第一个进程都是 PID&#x3D;1）；</li>
<li>父进程仍在原来的命名空间中，看到的子进程 PID 是另一个数值（比如 1234）；</li>
<li>子进程在自己的 PID 命名空间中看不到父进程的其他子进程，只能看到自己命名空间内的进程。</li>
</ol>
<h4 id="与-fork-的区别："><a href="#与-fork-的区别：" class="headerlink" title="与 fork() 的区别："></a>与 <code>fork()</code> 的区别：</h4><p><code>fork()</code> 创建的子进程会<strong>继承并共享父进程的所有命名空间</strong>（即和父进程在同一个命名空间）；而 <code>clone()</code> 可以通过标志让子进程<strong>使用全新的命名空间</strong>，实现隔离。</p>
<h3 id="2-unshare-：让当前进程“脱离”共享，创建自己的命名空间"><a href="#2-unshare-：让当前进程“脱离”共享，创建自己的命名空间" class="headerlink" title="2. unshare()：让当前进程“脱离”共享，创建自己的命名空间"></a>2. <code>unshare()</code>：让当前进程“脱离”共享，创建自己的命名空间</h3><p><code>unshare()</code> 的作用是<strong>让当前进程退出与其他进程共享的命名空间</strong>，并为自己创建一个新的命名空间（注意：不创建新进程，操作的是当前进程）。</p>
<h4 id="关键特点：-1"><a href="#关键特点：-1" class="headerlink" title="关键特点："></a>关键特点：</h4><ul>
<li><strong>不创建新进程</strong>：在当前进程中直接操作，修改当前进程的命名空间归属；</li>
<li><strong>“复制后独立”</strong>：解除共享时，内核会先复制一份当前命名空间的资源（比如挂载点、网络配置等），然后让当前进程使用这个复制的副本，之后当前进程对资源的修改不会影响原来的命名空间；</li>
<li><strong>场景</strong>：适用于当前进程需要“独立”出来，单独管理资源的情况（比如容器初始化时，让进程自己隔离出一个新的挂载命名空间）。</li>
</ul>
<h4 id="举例说明：-1"><a href="#举例说明：-1" class="headerlink" title="举例说明："></a>举例说明：</h4><p>假设进程 A 原本和进程 B 共享同一个挂载命名空间（即它们看到的文件系统挂载点完全一样）：</p>
<ol>
<li>进程 A 调用 <code>unshare(CLONE_NEWNS)</code>（<code>CLONE_NEWNS</code> 对应挂载命名空间）；</li>
<li>内核会复制一份当前的挂载点列表，作为进程 A 的新挂载命名空间；</li>
<li>进程 A 之后执行 <code>mount /dev/sdb1 /mnt</code> 挂载操作，只会影响自己的新命名空间，进程 B 看不到 <code>/mnt</code> 的新挂载；</li>
<li>进程 B 对挂载点的修改，也不会影响进程 A。</li>
</ol>
<h4 id="对应命令工具：unshare"><a href="#对应命令工具：unshare" class="headerlink" title="对应命令工具：unshare"></a>对应命令工具：<code>unshare</code></h4><p>Linux 提供了 <code>unshare</code> 命令（对应 <code>unshare()</code> 系统调用），可以在命令行中让进程“脱离共享”。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 unshare 命令创建一个新的挂载命名空间，并在其中执行 bash</span></span><br><span class="line">unshare --mount --fork /bin/bash</span><br></pre></td></tr></table></figure>

<p>执行后，这个 <code>bash</code> 进程就有了自己的挂载命名空间，在里面挂载的目录不会影响外部系统。</p>
<h3 id="3-setns-：让当前进程“加入”已有的命名空间"><a href="#3-setns-：让当前进程“加入”已有的命名空间" class="headerlink" title="3. setns()：让当前进程“加入”已有的命名空间"></a>3. <code>setns()</code>：让当前进程“加入”已有的命名空间</h3><p><code>setns()</code> 是“逆向操作”——它允许当前进程<strong>离开自己的命名空间，加入到另一个已存在的命名空间中</strong>（前提是能访问目标命名空间的文件描述符）。</p>
<h4 id="关键特点：-2"><a href="#关键特点：-2" class="headerlink" title="关键特点："></a>关键特点：</h4><ul>
<li><strong>加入已有命名空间</strong>：不是创建新的，而是“融入”一个已存在的命名空间；</li>
<li><strong>需要文件描述符</strong>：目标命名空间的标识通过文件描述符传递（通常来自 <code>/proc/[进程ID]/ns/</code> 目录下的文件，比如 <code>/proc/1234/ns/pid</code> 表示进程 1234 所在的 PID 命名空间）；</li>
<li><strong>场景</strong>：用于“进入”其他进程的命名空间（比如调试容器内的进程，查看容器的网络配置等）。</li>
</ul>
<h4 id="举例说明：-2"><a href="#举例说明：-2" class="headerlink" title="举例说明："></a>举例说明：</h4><p>假设系统中有一个容器进程 C（PID&#x3D;5678），它运行在自己的网络命名空间中（有独立的网卡 <code>eth0</code>）：</p>
<ol>
<li>我们的调试进程 D 想查看容器 C 的网络配置，需要加入 C 的网络命名空间；</li>
<li>进程 D 先打开容器 C 的网络命名空间文件：<code>fd = open(&quot;/proc/5678/ns/net&quot;, O_RDONLY)</code>；</li>
<li>调用 <code>setns(fd, 0)</code>，将自己加入到这个网络命名空间；</li>
<li>之后进程 D 执行 <code>ifconfig</code> 或 <code>ip addr</code>，看到的就是容器 C 内的网络接口（比如 <code>eth0</code> 的 IP 是容器内的地址），而不是主机的网络。</li>
</ol>
<h4 id="对应命令工具：nsenter"><a href="#对应命令工具：nsenter" class="headerlink" title="对应命令工具：nsenter"></a>对应命令工具：<code>nsenter</code></h4><p><code>nsenter</code> 命令基于 <code>setns()</code> 实现，用于“进入”其他进程的命名空间执行命令。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 PID=5678 进程的网络命名空间，执行 ip addr 查看网络</span></span><br><span class="line">nsenter --net=/proc/5678/ns/net ip addr</span><br></pre></td></tr></table></figure>


<h3 id="总结：三个系统调用的核心区别"><a href="#总结：三个系统调用的核心区别" class="headerlink" title="总结：三个系统调用的核心区别"></a>总结：三个系统调用的核心区别</h3><table>
<thead>
<tr>
<th>系统调用</th>
<th>核心操作</th>
<th>是否创建新进程</th>
<th>命名空间来源</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>clone()</code></td>
<td>创建新进程 + 新命名空间</td>
<td>是</td>
<td>全新创建</td>
<td>启动新容器（如创建隔离的子进程）</td>
</tr>
<tr>
<td><code>unshare()</code></td>
<td>当前进程创建新命名空间</td>
<td>否</td>
<td>复制原命名空间后独立</td>
<td>让当前进程“隔离”出独立资源</td>
</tr>
<tr>
<td><code>setns()</code></td>
<td>当前进程加入已有命名空间</td>
<td>否</td>
<td>其他进程已有的命名空间</td>
<td>调试&#x2F;访问其他命名空间（如容器）</td>
</tr>
</tbody></table>
<p>通过这三个系统调用，Linux 实现了命名空间的创建、隔离和切换，是容器技术（如 Docker、Kubernetes）实现资源隔离的核心底层支撑。理解它们的区别，就能明白容器内的进程如何被“隔离”，以及外部如何与容器内的资源交互。</p>
<h2 id="命名空间——挂载-mnt"><a href="#命名空间——挂载-mnt" class="headerlink" title="命名空间——挂载 (mnt)"></a>命名空间——挂载 (mnt)</h2><p>挂载命名空间（mnt namespace）是Linux最早实现的命名空间，它的核心功能是：<strong>让不同的进程组拥有独立的“挂载点集合”</strong>。<br>也就是说：  </p>
<ul>
<li>进程A在自己的挂载命名空间里挂载了一个设备到 <code>/test</code>，进程B如果在另一个挂载命名空间，它的 <code>/test</code> 可能还是空的，完全看不到A的挂载；  </li>
<li>进程A卸载了某个挂载点，也不会影响进程B看到的文件系统。</li>
</ul>
<h3 id="创建并使用挂载命名空间"><a href="#创建并使用挂载命名空间" class="headerlink" title="创建并使用挂载命名空间"></a>创建并使用挂载命名空间</h3><h5 id="步骤1：在第一个终端创建带文件的-tmpfs（新命名空间）"><a href="#步骤1：在第一个终端创建带文件的-tmpfs（新命名空间）" class="headerlink" title="步骤1：在第一个终端创建带文件的 tmpfs（新命名空间）"></a>步骤1：在第一个终端创建带文件的 tmpfs（新命名空间）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端A：创建新的挂载命名空间并进入</span></span><br><span class="line"><span class="comment"># 1. 用 unshare -m 创建并进入新的挂载命名空间（-m 对应挂载命名空间）</span></span><br><span class="line"><span class="built_in">sudo</span> unshare -m /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时你进入了一个新的bash进程，它已经在新的挂载命名空间里了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 在当前目录创建一个文件夹作为挂载点</span></span><br><span class="line"><span class="built_in">mkdir</span> mount-dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 挂载一个tmpfs（内存虚拟文件系统，数据只存在内存中）到 mount-dir</span></span><br><span class="line">mount -n -o size=10m -t tmpfs tmpfs mount-dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看挂载结果：会看到 mount-dir 已经挂载了tmpfs</span></span><br><span class="line"><span class="built_in">df</span> mount-dir  <span class="comment"># 能看到一行关于 mount-dir 的挂载信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 在这个挂载点里创建几个文件</span></span><br><span class="line"><span class="built_in">touch</span> mount-dir/&#123;0,1,2&#125;</span><br><span class="line"><span class="built_in">ls</span> mount-dir  <span class="comment"># 能看到 0、1、2 三个文件</span></span><br></pre></td></tr></table></figure>

<h5 id="步骤2：在第二个终端直接挂载-tmpfs-到同一目录（原命名空间）"><a href="#步骤2：在第二个终端直接挂载-tmpfs-到同一目录（原命名空间）" class="headerlink" title="步骤2：在第二个终端直接挂载 tmpfs 到同一目录（原命名空间）"></a>步骤2：在第二个终端直接挂载 tmpfs 到同一目录（原命名空间）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端B：使用系统默认的挂载命名空间（不执行unshare）</span></span><br><span class="line"><span class="comment"># 注意：如果mount-dir不存在，先创建</span></span><br><span class="line"><span class="built_in">mkdir</span> -p mount-dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接挂载tmpfs到mount-dir</span></span><br><span class="line"><span class="built_in">sudo</span> mount -n -o size=10m -t tmpfs tmpfs mount-dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line"><span class="built_in">ls</span> mount-dir  <span class="comment"># 输出：（空的！看不到终端A创建的0、1、2）</span></span><br></pre></td></tr></table></figure>


<h5 id="为什么看不到？核心原因：两个终端在不同的挂载命名空间"><a href="#为什么看不到？核心原因：两个终端在不同的挂载命名空间" class="headerlink" title="为什么看不到？核心原因：两个终端在不同的挂载命名空间"></a>为什么看不到？核心原因：两个终端在不同的挂载命名空间</h5><ol>
<li><p><strong>终端A的 <code>mount-dir</code> 属于“新挂载命名空间”</strong>：<br>它挂载的 <code>tmpfs</code> 是这个命名空间独有的，相当于一块“独立的内存区域”，里面的文件（0、1、2）只属于这个命名空间。</p>
</li>
<li><p><strong>终端B的 <code>mount-dir</code> 属于“默认挂载命名空间”</strong>：<br>它挂载的 <code>tmpfs</code> 是另一块“独立的内存区域”，和终端A的 <code>tmpfs</code> 没有任何关联（即使挂载点目录名称相同）。<br>这就像两个完全隔离的“内存文件夹”，虽然都叫 <code>mount-dir</code>，但里面的内容各自独立。</p>
</li>
</ol>
<h5 id="如何让另一个终端看到这三个文件？"><a href="#如何让另一个终端看到这三个文件？" class="headerlink" title="如何让另一个终端看到这三个文件？"></a>如何让另一个终端看到这三个文件？</h5><p>必须让另一个终端<strong>加入终端A所在的挂载命名空间</strong>，才能共享同一个 <code>tmpfs</code> 挂载点。具体步骤：</p>
<ol>
<li><p><strong>在终端A中查看当前进程的PID</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端A中执行（此时仍在unshare创建的bash里）</span></span><br><span class="line"><span class="built_in">echo</span> $$  <span class="comment"># 假设输出 PID=1234</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在终端B中加入终端A的挂载命名空间</strong>：<br>使用 <code>nsenter</code> 命令（基于 <code>setns()</code> 系统调用），进入终端A的命名空间：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端B中执行</span></span><br><span class="line"><span class="built_in">sudo</span> nsenter --mount=/proc/1234/ns/mnt /bin/bash</span><br></pre></td></tr></table></figure>

<p>此时终端B的bash已经进入了终端A的挂载命名空间。</p>
</li>
<li><p><strong>在终端B中查看文件</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端B中执行（已进入终端A的命名空间）</span></span><br><span class="line"><span class="built_in">ls</span> mount-dir  <span class="comment"># 输出：0 1 2（成功看到文件！）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li><code>tmpfs</code> 虽然在内存中，但<strong>不同挂载命名空间的 <code>tmpfs</code> 是完全隔离的</strong>，即使挂载点目录名称相同，内容也不互通。  </li>
<li>只有让进程“加入同一个挂载命名空间”，才能共享该命名空间内的 <code>tmpfs</code> 挂载点及其中的文件（通过 <code>nsenter</code> 命令实现）。</li>
</ul>
<p>这正是命名空间“资源隔离”的核心：<strong>同名目录不等于同一资源，关键看是否在同一个命名空间中</strong>。</p>
<h2 id="命名空间——进程ID（pid）"><a href="#命名空间——进程ID（pid）" class="headerlink" title="命名空间——进程ID（pid）"></a>命名空间——进程ID（pid）</h2><ol>
<li><p>PID命名空间的本质是<strong>让不同命名空间的进程拥有独立的PID编号体系</strong><br>一个进程在自己的命名空间内有一个“局部PID”（比如命名空间内的<code>PID=1</code>），在主机全局命名空间内还有一个“全局PID”（比如主机上的<code>PID=1234</code>）。<br>举例：容器内的<code>bash</code>进程，在容器的PID命名空间里是<code>PID=1</code>，但在主机上看可能是<code>PID=5678</code>。</p>
</li>
<li><p><strong>嵌套结构</strong>：<br>PID命名空间可以嵌套。比如“父命名空间”创建“子命名空间”，子命名空间的进程能看到父命名空间的进程，但父命名空间看不到子命名空间的进程（除非显式配置）。</p>
</li>
<li><p><strong>PID&#x3D;1的特殊性</strong>：<br>每个PID命名空间的第一个进程会被分配<code>PID=1</code>，它的角色类似系统的<code>init</code>进程：</p>
</li>
</ol>
<ul>
<li>负责回收该命名空间内的“僵尸进程”（如果它退出，内核会强制终止命名空间内所有进程）；  </li>
<li>这就是为什么在容器中直接杀掉<code>PID=1</code>的进程，整个容器会立即退出。</li>
</ul>
<h3 id="创建并使用挂载命名空间-1"><a href="#创建并使用挂载命名空间-1" class="headerlink" title="创建并使用挂载命名空间"></a>创建并使用挂载命名空间</h3><h4 id="步骤1：创建新PID命名空间并重新挂载-proc"><a href="#步骤1：创建新PID命名空间并重新挂载-proc" class="headerlink" title="步骤1：创建新PID命名空间并重新挂载/proc"></a>步骤1：创建新PID命名空间并重新挂载<code>/proc</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行命令，进入新的bash进程（在新PID命名空间中）</span></span><br><span class="line"><span class="built_in">sudo</span> unshare -fp --mount-proc /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时在新bash中查看PID：当前bash是这个命名空间的第一个进程，所以PID=1</span></span><br><span class="line"><span class="built_in">echo</span> $$  <span class="comment"># 输出：1（局部PID）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程列表：只能看到当前命名空间内的进程（只有bash自己）</span></span><br><span class="line">ps aux  <span class="comment"># 输出中只有1个进程（PID=1的bash）</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤2：在新命名空间中创建子进程"><a href="#步骤2：在新命名空间中创建子进程" class="headerlink" title="步骤2：在新命名空间中创建子进程"></a>步骤2：在新命名空间中创建子进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在新bash中启动一个sleep进程（子进程）</span></span><br><span class="line"><span class="built_in">sleep</span> 3600 &amp;  <span class="comment"># 后台运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程：sleep的PID在当前命名空间中是2</span></span><br><span class="line">ps aux  <span class="comment"># 输出：PID=1（bash）、PID=2（sleep）</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤3：在主机终端查看（全局视角）"><a href="#步骤3：在主机终端查看（全局视角）" class="headerlink" title="步骤3：在主机终端查看（全局视角）"></a>步骤3：在主机终端查看（全局视角）</h4><p>打开另一个终端（主机默认命名空间）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找新命名空间中bash的全局PID（假设是1234）</span></span><br><span class="line">pgrep -f <span class="string">&quot;unshare -fp --mount-proc&quot;</span>  <span class="comment"># 输出：1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该进程的子进程（sleep的全局PID，比如1235）</span></span><br><span class="line">ps -ef | grep 1234  <span class="comment"># 输出：1234（bash）、1235（sleep）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但主机终端中，sleep的PID是1235（全局PID），和新命名空间内的PID=2完全不同</span></span><br></pre></td></tr></table></figure>

<h3 id="sudo-unshare-fp-mount-proc-到底做了什么？"><a href="#sudo-unshare-fp-mount-proc-到底做了什么？" class="headerlink" title="sudo unshare -fp --mount-proc 到底做了什么？"></a><code>sudo unshare -fp --mount-proc</code> 到底做了什么？</h3><p>这个命令是创建并进入新PID命名空间的标准操作，我们一步步拆解：</p>
<h4 id="1-sudo：获取权限"><a href="#1-sudo：获取权限" class="headerlink" title="1. sudo：获取权限"></a>1. <code>sudo</code>：获取权限</h4><p>PID命名空间的创建需要root权限（普通用户受限制），所以用<code>sudo</code>提权。</p>
<h4 id="2-f（-fork）：安全创建新进程"><a href="#2-f（-fork）：安全创建新进程" class="headerlink" title="2. -f（--fork）：安全创建新进程"></a>2. <code>-f</code>（<code>--fork</code>）：安全创建新进程</h4><p><code>unshare</code>默认会让“当前进程”进入新命名空间，但这样可能影响当前shell。<code>-f</code>会先<code>fork</code>一个新进程，让新进程进入新命名空间，当前shell不受影响（更安全）。</p>
<h4 id="3-p（-pid）：创建新的PID命名空间"><a href="#3-p（-pid）：创建新的PID命名空间" class="headerlink" title="3. -p（--pid）：创建新的PID命名空间"></a>3. <code>-p</code>（<code>--pid</code>）：创建新的PID命名空间</h4><p>这是核心：告诉内核为新进程创建一个<strong>全新的PID命名空间</strong>。新命名空间内的进程将拥有独立的PID编号，看不到外部命名空间的进程。</p>
<h4 id="4-mount-proc：重新挂载-proc文件系统"><a href="#4-mount-proc：重新挂载-proc文件系统" class="headerlink" title="4. --mount-proc：重新挂载/proc文件系统"></a>4. <code>--mount-proc</code>：重新挂载<code>/proc</code>文件系统</h4><p><code>/proc</code>是Linux的“进程信息虚拟文件系统”，里面的<code>/proc/[PID]</code>目录对应每个进程的详细信息。但<code>/proc</code>默认展示的是“当前进程所在命名空间”的进程信息。  </p>
<p>如果不重新挂载<code>/proc</code>：  </p>
<ul>
<li>即使进入了新的PID命名空间，<code>/proc</code>仍然指向原来命名空间的视图（比如主机的<code>/proc</code>）；  </li>
<li>此时执行<code>ps</code>或<code>top</code>，看到的还是主机的进程，无法体现PID命名空间的隔离效果。</li>
</ul>
<p><code>--mount-proc</code>的作用是：在新的PID命名空间中，自动将<code>/proc</code>重新挂载为“当前命名空间的进程视图”。这样执行<code>ps</code>时，只能看到新命名空间内的进程。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>PID命名空间通过“独立的PID编号体系”实现进程隔离，而<code>--mount-proc</code>（或手动重新挂载<code>/proc</code>）是让这种隔离“可见”的关键（确保<code>ps</code>等工具只显示当前命名空间的进程）。  </p>
<p>这正是容器技术中“进程隔离”的底层原理：每个容器就是一个独立的PID命名空间，容器内的<code>PID=1</code>进程（如<code>nginx</code>、<code>bash</code>）与主机的<code>PID=1</code>（<code>systemd</code>）完全隔离，彼此互不可见。</p>
<h2 id="命名空间——网络（net）"><a href="#命名空间——网络（net）" class="headerlink" title="命名空间——网络（net）"></a>命名空间——网络（net）</h2><p>网络命名空间在 Linux 2.6.29 (2009) 中完成，可用于虚拟化网络协议栈。每个网络命名空间都包含其自己的资源属性<code>/proc/net</code>。此外，网络命名空间在初始创建时，会包含一个环回接口。</p>
<h4 id="1-创建网络命名空间：建一个“新房间”"><a href="#1-创建网络命名空间：建一个“新房间”" class="headerlink" title="1. 创建网络命名空间：建一个“新房间”"></a>1. 创建网络命名空间：建一个“新房间”</h4><p>创建网络命名空间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> unshare -n <span class="comment"># 创建一个临时的网络命名空间（退出后自动销毁）</span></span><br><span class="line"><span class="built_in">sudo</span> ip netns add mynet <span class="comment">#创建一个“持久化”的网络命名空间（名字叫 `mynet`），即使里面没有进程运行也不会消失 </span></span><br></pre></td></tr></table></figure>

<p>查看已有的命名空间：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip netns list  <span class="comment"># 会显示刚才创建的 mynet</span></span><br></pre></td></tr></table></figure>


<h4 id="2-进入命名空间操作：“走进房间”"><a href="#2-进入命名空间操作：“走进房间”" class="headerlink" title="2. 进入命名空间操作：“走进房间”"></a>2. 进入命名空间操作：“走进房间”</h4><p>要操作 <code>mynet</code> 这个“房间”里的网络，需要用 <code>ip netns exec</code> 命令“进入房间”：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> mynet [命令]  <span class="comment"># 表示在 mynet 命名空间中执行某个命令</span></span><br></pre></td></tr></table></figure>

<p>比如，查看 <code>mynet</code> 里的网卡：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> mynet ip <span class="built_in">link</span> show</span><br></pre></td></tr></table></figure>

<p>此时会看到一个叫 <code>lo</code> 的网卡（环回接口），这是每个网络命名空间默认自带的“内部回环接口”（相当于房间里的“内部电话”，用于进程自己跟自己通信）。</p>
<h4 id="3-启用环回接口：“接通内部电话”"><a href="#3-启用环回接口：“接通内部电话”" class="headerlink" title="3. 启用环回接口：“接通内部电话”"></a>3. 启用环回接口：“接通内部电话”</h4><p>默认情况下，<code>lo</code> 接口是关闭的（就像内部电话没插线），需要手动打开：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> mynet ip <span class="built_in">link</span> <span class="built_in">set</span> dev lo up</span><br></pre></td></tr></table></figure>

<p>打开后，命名空间内的程序可以通过 <code>127.0.0.1</code> 访问自己（比如本地服务）。</p>
<h4 id="4-创建-veth-对：拉一根“虚拟网线”"><a href="#4-创建-veth-对：拉一根“虚拟网线”" class="headerlink" title="4. 创建 veth 对：拉一根“虚拟网线”"></a>4. 创建 veth 对：拉一根“虚拟网线”</h4><p>现在 <code>mynet</code> 这个房间是完全孤立的，和主机（默认命名空间）没有连接。怎么让它们通信？需要一根“虚拟网线”——veth 对（虚拟以太网接口对）。  </p>
<p>veth 对是一对“捆绑在一起的虚拟网卡”：就像一根网线的两端，一端插在主机（默认命名空间），另一端插在 <code>mynet</code> 房间，这样两边就能传数据了。  </p>
<p>创建 veth 对：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name veth1</span><br></pre></td></tr></table></figure>

<ul>
<li>这会创建两个虚拟网卡：<code>veth0</code> 和 <code>veth1</code>，它们是“一对”——<code>veth0</code> 收到的数据会自动传给 <code>veth1</code>，反之亦然。</li>
</ul>
<h4 id="5-连接命名空间：把网线“插进房间”"><a href="#5-连接命名空间：把网线“插进房间”" class="headerlink" title="5. 连接命名空间：把网线“插进房间”"></a>5. 连接命名空间：把网线“插进房间”</h4><p>现在 <code>veth0</code> 和 <code>veth1</code> 都在主机的默认命名空间里，我们需要把 <code>veth1</code> 移到 <code>mynet</code> 房间：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 netns mynet</span><br></pre></td></tr></table></figure>

<p>此时：  </p>
<ul>
<li>主机（默认命名空间）里只剩 <code>veth0</code>；  </li>
<li><code>mynet</code> 房间里多了 <code>veth1</code>（相当于网线一端插进了房间）。</li>
</ul>
<h4 id="6-配置-IP-地址：给“网线接口”分配门牌号"><a href="#6-配置-IP-地址：给“网线接口”分配门牌号" class="headerlink" title="6. 配置 IP 地址：给“网线接口”分配门牌号"></a>6. 配置 IP 地址：给“网线接口”分配门牌号</h4><p>有了网线，还需要给两端的接口分配 IP 地址（门牌号）才能通信：  </p>
<ul>
<li><p>给 <code>mynet</code> 房间里的 <code>veth1</code> 分配 IP：<code>172.2.0.1/24</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> mynet ip addr add 172.2.0.1/24 dev veth1</span><br><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> mynet ip <span class="built_in">link</span> <span class="built_in">set</span> dev veth1 up  <span class="comment"># 启用这个接口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>给主机的 <code>veth0</code> 分配 IP：<code>172.2.0.2/24</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip addr add 172.2.0.2/24 dev veth0</span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev veth0 up  <span class="comment"># 启用这个接口</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-测试通信：两个“房间”能通话了"><a href="#7-测试通信：两个“房间”能通话了" class="headerlink" title="7. 测试通信：两个“房间”能通话了"></a>7. 测试通信：两个“房间”能通话了</h4><p>现在主机和 <code>mynet</code> 房间通过 veth 对连接，应该能互相 ping 通：  </p>
<ul>
<li><p>主机 ping <code>mynet</code> 里的 <code>veth1</code>（IP：172.2.0.1）：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c1 172.2.0.1  <span class="comment"># 成功收到回复</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mynet</code> 房间 ping 主机的 <code>veth0</code>（IP：172.2.0.2）：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> mynet ping -c1 172.2.0.2  <span class="comment"># 成功收到回复</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-为什么访问不了互联网？"><a href="#8-为什么访问不了互联网？" class="headerlink" title="8. 为什么访问不了互联网？"></a>8. 为什么访问不了互联网？</h4><p>此时 <code>mynet</code> 房间只能和主机通信，但不能上互联网（比如 ping 百度）。原因是：<br><code>mynet</code> 房间的“导航地图”（路由表）里，没有“如何走到互联网”的路线。  </p>
<p>要解决这个问题，需要：  </p>
<ol>
<li>在主机上创建一个“网桥”（相当于路由器），连接主机的物理网卡（能上互联网）和 <code>veth0</code>；  </li>
<li>在 <code>mynet</code> 房间里设置“默认路由”：告诉房间里的设备“上网请找主机的 <code>veth0</code>（172.2.0.2）”；  </li>
<li>主机开启 NAT 转发（相当于路由器的“地址转换”功能），让 <code>mynet</code> 的流量能通过主机的网卡访问互联网。</li>
</ol>
<h2 id="命名空间——进程间通信（ipc）"><a href="#命名空间——进程间通信（ipc）" class="headerlink" title="命名空间——进程间通信（ipc）"></a>命名空间——进程间通信（ipc）</h2><h3 id="什么是-IPC？"><a href="#什么是-IPC？" class="headerlink" title="什么是 IPC？"></a>什么是 IPC？</h3><p>IPC（进程间通信）是指不同进程之间交换数据的方式，Linux 中常见的 IPC 机制包括：  </p>
<ul>
<li><strong>System V IPC</strong>：如消息队列（用于进程间发送消息）、共享内存（多个进程共享同一块内存区域，高效传递数据）、信号量（控制多个进程对共享资源的访问顺序）。  </li>
<li><strong>POSIX 消息队列</strong>：另一种消息传递机制，比 System V 消息队列更灵活。</li>
</ul>
<p>这些 IPC 资源都有唯一的“标识符”（比如共享内存的 <code>shmid</code>、消息队列的 <code>msgid</code>），进程通过标识符找到对应的资源进行通信。</p>
<h3 id="为什么需要-IPC-命名空间？"><a href="#为什么需要-IPC-命名空间？" class="headerlink" title="为什么需要 IPC 命名空间？"></a>为什么需要 IPC 命名空间？</h3><p>没有 IPC 命名空间时，<strong>所有进程共享系统全局的 IPC 资源池</strong>。这会导致两个问题：  </p>
<ol>
<li><strong>标识符冲突</strong>：不同程序可能使用相同的 IPC 标识符，导致错误（比如进程 A 创建的共享内存 <code>shmid=123</code>，进程 B 误操作这个 <code>shmid=123</code>，导致数据混乱）。  </li>
<li><strong>安全风险</strong>：恶意进程可能通过 IPC 资源窥探或干扰其他进程（比如读取不属于自己的共享内存数据）。</li>
</ol>
<p>IPC 命名空间的作用就是<strong>给不同进程组划分“独立的 IPC 资源池”</strong>：每个命名空间内的 IPC 标识符是独立的，不同命名空间的进程即使使用相同的标识符，也访问不到对方的 IPC 资源。</p>
<h3 id="IPC-命名空间的核心功能：隔离-IPC-资源"><a href="#IPC-命名空间的核心功能：隔离-IPC-资源" class="headerlink" title="IPC 命名空间的核心功能：隔离 IPC 资源"></a>IPC 命名空间的核心功能：隔离 IPC 资源</h3><h4 id="1-隔离的具体对象"><a href="#1-隔离的具体对象" class="headerlink" title="1. 隔离的具体对象"></a>1. 隔离的具体对象</h4><ul>
<li><strong>System V IPC 对象</strong>：  <ul>
<li>共享内存（<code>shmget</code> 创建的内存段）；  </li>
<li>消息队列（<code>msgget</code> 创建的消息队列）；  </li>
<li>信号量（<code>semget</code> 创建的信号量集）。</li>
</ul>
</li>
<li><strong>POSIX 消息队列</strong>：通过 <code>mq_open</code> 创建的消息队列。</li>
</ul>
<p>这些资源在不同 IPC 命名空间中完全独立，彼此不可见。</p>
<h4 id="2-举例说明：共享内存的隔离"><a href="#2-举例说明：共享内存的隔离" class="headerlink" title="2. 举例说明：共享内存的隔离"></a>2. 举例说明：共享内存的隔离</h4><p>假设场景：  </p>
<ul>
<li>进程 A 在“默认命名空间”中创建共享内存，标识符 <code>shmid=1</code>，写入数据“Hello”；  </li>
<li>进程 B 在“新的 IPC 命名空间”中也创建共享内存，标识符 <code>shmid=1</code>，写入数据“World”。</li>
</ul>
<p>结果：  </p>
<ul>
<li>进程 A 只能看到自己命名空间中 <code>shmid=1</code> 的数据（“Hello”）；  </li>
<li>进程 B 只能看到自己命名空间中 <code>shmid=1</code> 的数据（“World”）；  </li>
<li>两者的 <code>shmid=1</code> 是完全独立的资源，不会相互覆盖或干扰。</li>
</ul>
<h4 id="3-命名空间销毁时的自动清理"><a href="#3-命名空间销毁时的自动清理" class="headerlink" title="3. 命名空间销毁时的自动清理"></a>3. 命名空间销毁时的自动清理</h4><p>当一个 IPC 命名空间被销毁（比如该命名空间中最后一个进程退出），内核会<strong>自动删除该命名空间内所有的 IPC 资源</strong>（共享内存、消息队列等），无需手动清理，避免资源泄漏。</p>
<h3 id="IPC-命名空间的典型应用：容器的安全隔离"><a href="#IPC-命名空间的典型应用：容器的安全隔离" class="headerlink" title="IPC 命名空间的典型应用：容器的安全隔离"></a>IPC 命名空间的典型应用：容器的安全隔离</h3><p>在 Docker 等容器技术中，每个容器会被分配独立的 IPC 命名空间：  </p>
<ul>
<li>容器内的进程使用 IPC 资源（比如共享内存）时，只会在容器内部生效，不会影响主机或其他容器；  </li>
<li>即使容器内的进程和主机进程使用相同的 IPC 标识符，也不会产生冲突，保证了容器的安全性和独立性。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>IPC 命名空间的核心是<strong>隔离进程间通信的资源池</strong>，让不同命名空间的进程“各用各的 IPC 资源”，避免标识符冲突和恶意访问。它是 Linux 容器实现“完全隔离”的重要组成部分，确保容器内的 IPC 操作不会干扰外部系统。</p>
<h2 id="命名空间——UNIX-分时系统-uts"><a href="#命名空间——UNIX-分时系统-uts" class="headerlink" title="命名空间——UNIX 分时系统 (uts)"></a>命名空间——UNIX 分时系统 (uts)</h2><p>UTS 命名空间（UTS Namespace）是 Linux 中专门用于<strong>隔离主机名（hostname）和域名（domain name）</strong> 的机制，它能让不同命名空间的进程拥有独立的主机标识，就像给每个“隔离环境”贴了个独立的“名字标签”。</p>
<h3 id="什么是-UTS？"><a href="#什么是-UTS？" class="headerlink" title="什么是 UTS？"></a>什么是 UTS？</h3><p>UTS 是“UNIX Time-Sharing”（UNIX 分时系统）的缩写，源于早期 UNIX 系统对主机标识的管理。在 Linux 中，UTS 命名空间的核心作用就是<strong>让进程组可以拥有自己独立的主机名和域名</strong>，与系统其他部分隔离开。</p>
<p>简单说：没有 UTS 命名空间时，整个系统的所有进程看到的主机名都是一样的（比如 <code>localhost</code> 或你给服务器设置的名字）；有了 UTS 命名空间，每个命名空间可以单独设置自己的主机名，互不影响。</p>
<h3 id="UTS-命名空间的核心功能：隔离主机标识"><a href="#UTS-命名空间的核心功能：隔离主机标识" class="headerlink" title="UTS 命名空间的核心功能：隔离主机标识"></a>UTS 命名空间的核心功能：隔离主机标识</h3><h4 id="1-隔离的对象"><a href="#1-隔离的对象" class="headerlink" title="1. 隔离的对象"></a>1. 隔离的对象</h4><ul>
<li><strong>主机名（hostname）</strong>：系统的“名字”，比如 <code>docker-host</code>、<code>web-server</code>，可以通过 <code>hostname</code> 命令查看或修改。  </li>
<li><strong>域名（domain name）</strong>：系统的网络域名（主要用于 DNS 解析相关场景），可以通过 <code>hostname -d</code> 查看。</li>
</ul>
<p>UTS 命名空间会让这两个标识在不同命名空间中完全独立——修改一个命名空间的主机名，其他命名空间看不到变化。</p>
<h4 id="2-实际操作：sudo-unshare-u-做了什么？"><a href="#2-实际操作：sudo-unshare-u-做了什么？" class="headerlink" title="2. 实际操作：sudo unshare -u 做了什么？"></a>2. 实际操作：<code>sudo unshare -u</code> 做了什么？</h4><p><code>sudo unshare -u</code> 命令的作用是：<strong>创建一个新的 UTS 命名空间，并让当前进程进入这个命名空间</strong>（<code>-u</code> 是 <code>--uts</code> 的缩写，对应 UTS 命名空间）。  </p>
<p>我们通过步骤演示隔离效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1：在默认命名空间查看主机名（假设主机名是 &quot;myhost&quot;）</span></span><br><span class="line">hostname  <span class="comment"># 输出：myhost</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2：创建新的 UTS 命名空间并进入（用 bash 作为新进程）</span></span><br><span class="line"><span class="built_in">sudo</span> unshare -u /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3：在新命名空间中修改主机名</span></span><br><span class="line">hostname container-1  <span class="comment"># 设置新主机名为 &quot;container-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4：在新命名空间中查看主机名（已生效）</span></span><br><span class="line">hostname  <span class="comment"># 输出：container-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤5：打开另一个终端（默认命名空间），查看主机名（不变）</span></span><br><span class="line">hostname  <span class="comment"># 输出：myhost（仍然是原来的主机名）</span></span><br></pre></td></tr></table></figure>

<p><strong>核心效果</strong>：新 UTS 命名空间中的主机名修改，完全不会影响默认命名空间，两者的“名字标识”彻底隔离。</p>
<h3 id="为什么-UTS-命名空间对容器很重要？"><a href="#为什么-UTS-命名空间对容器很重要？" class="headerlink" title="为什么 UTS 命名空间对容器很重要？"></a>为什么 UTS 命名空间对容器很重要？</h3><p>容器的核心目标是“模拟一个独立的操作系统环境”，而主机名是操作系统的基础标识之一。比如：  </p>
<ul>
<li>在 Docker 容器中，我们希望每个容器有自己的主机名（比如 <code>web-container</code>、<code>db-container</code>），这样应用程序在容器内获取主机名时，得到的是容器自己的名字，而不是宿主机的名字；  </li>
<li>如果没有 UTS 命名空间，所有容器和宿主机共享同一个主机名，会导致应用程序识别错误（比如日志中分不清是哪个容器产生的，或依赖主机名的服务无法正常工作）。</li>
</ul>
<p>UTS 命名空间通过隔离主机名，让容器实现了“独立身份标识”，是容器“看起来像一个独立系统”的重要支撑。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>UTS 命名空间的作用很专一：<strong>隔离主机名和域名</strong>，让不同进程组可以拥有独立的标识。它虽然简单，但对容器技术至关重要——没有它，容器就无法拥有“自己的名字”，难以模拟真实的独立系统环境。  </p>
<p>一句话概括：UTS 命名空间给了每个隔离环境一个“独立的身份牌”。</p>
<h2 id="命名空间——时间-time"><a href="#命名空间——时间-time" class="headerlink" title="命名空间——时间 (time)"></a>命名空间——时间 (time)</h2><p>Time 命名空间（Time Namespace）是 Linux 内核 5.6 版本后引入的新特性，专门用于<strong>隔离进程看到的系统时间</strong>，让不同命名空间的进程可以拥有独立的时钟视图，就像给每个“隔离环境”配备了一个独立的“时间流”。</p>
<h3 id="什么是-Time-命名空间？"><a href="#什么是-Time-命名空间？" class="headerlink" title="什么是 Time 命名空间？"></a>什么是 Time 命名空间？</h3><p>Time 命名空间的核心作用是<strong>让进程组可以拥有自己独立的系统时间（包括墙上时间和单调时间）</strong>，与系统其他部分的时间隔离开来。这里的“时间”主要指两类：</p>
<ul>
<li><strong>墙上时间（Wall Time）</strong>：即真实世界的时间（如 <code>2023-10-01 12:00:00</code>），可通过 <code>date</code> 命令查看。</li>
<li><strong>单调时间（Monotonic Time）</strong>：从系统启动开始计数的时间（不会因墙上时间修改而变化），用于程序中的时间间隔计算。</li>
</ul>
<p>简单说：没有 Time 命名空间时，所有进程看到的系统时间完全一致，修改墙上时间会影响所有进程；有了 Time 命名空间，每个命名空间可以单独调整自己的时间，互不干扰。</p>
<h3 id="Time-命名空间的核心功能：隔离系统时间"><a href="#Time-命名空间的核心功能：隔离系统时间" class="headerlink" title="Time 命名空间的核心功能：隔离系统时间"></a>Time 命名空间的核心功能：隔离系统时间</h3><h4 id="1-隔离的对象-1"><a href="#1-隔离的对象-1" class="headerlink" title="1. 隔离的对象"></a>1. 隔离的对象</h4><ul>
<li><strong>墙上时间（CLOCK_REALTIME）</strong>：进程通过 <code>clock_gettime(CLOCK_REALTIME)</code> 系统调用获取的时间，也是 <code>date</code> 命令显示的时间。</li>
<li><strong>单调时间（CLOCK_MONOTONIC）</strong>：进程通过 <code>clock_gettime(CLOCK_MONOTONIC)</code> 获取的时间，用于测量时间间隔（如程序中的“等待 5 秒”）。</li>
</ul>
<p>Time 命名空间会让这两种时间在不同命名空间中独立——修改一个命名空间的墙上时间，其他命名空间的时间保持不变；每个命名空间的单调时间也可以有独立的偏移量。</p>
<h4 id="2-实际操作：sudo-unshare-T-做了什么？"><a href="#2-实际操作：sudo-unshare-T-做了什么？" class="headerlink" title="2. 实际操作：sudo unshare -T 做了什么？"></a>2. 实际操作：<code>sudo unshare -T</code> 做了什么？</h4><p><code>sudo unshare -T</code> 命令的作用是：<strong>创建一个新的 Time 命名空间，并让当前进程进入这个命名空间</strong>（<code>-T</code> 是 <code>--time</code> 的缩写，对应 Time 命名空间）。</p>
<p>我们通过步骤演示隔离效果（需 Linux 内核 ≥5.6）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1：在默认命名空间查看当前时间（假设当前时间为 &quot;2023-10-01 12:00:00&quot;）</span></span><br><span class="line"><span class="built_in">date</span>  <span class="comment"># 输出：Sun Oct  1 12:00:00 CST 2023</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2：创建新的 Time 命名空间并进入（用 bash 作为新进程）</span></span><br><span class="line"><span class="built_in">sudo</span> unshare -T /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3：在新命名空间中修改墙上时间（需要 CAP_SYS_TIME 权限，即 root）</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2023-10-01 13:00:00&quot;</span>  <span class="comment"># 设置新时间为下午1点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4：在新命名空间中查看时间（已生效）</span></span><br><span class="line"><span class="built_in">date</span>  <span class="comment"># 输出：Sun Oct  1 13:00:00 CST 2023</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤5：打开另一个终端（默认命名空间），查看时间（不变）</span></span><br><span class="line"><span class="built_in">date</span>  <span class="comment"># 输出：Sun Oct  1 12:00:00 CST 2023（仍然是原来的时间）</span></span><br></pre></td></tr></table></figure>

<p><strong>核心效果</strong>：新 Time 命名空间中的时间修改，完全不会影响默认命名空间，两者的“时间流”彻底隔离。</p>
<blockquote>
<p>注意：如果使用WSL，可能出现在新命名空间中修改墙上时间但是没有生效的情况</p>
</blockquote>
<p><img src="D:\Project\Under-Container\01ContainerFundamentals\images\00.png" alt="00"></p>
<blockquote>
<p>可以通过如下方法判断是否成功创建了time命名空间</p>
</blockquote>
<p><img src="D:\Project\Under-Container\01ContainerFundamentals\images\01.png" alt="00"></p>
<h3 id="特殊说明：time-for-children-的作用"><a href="#特殊说明：time-for-children-的作用" class="headerlink" title="特殊说明：time_for_children 的作用"></a>特殊说明：<code>time_for_children</code> 的作用</h3><p>在 <code>/proc/[PID]/ns/</code> 目录中，除了 <code>time</code> 文件，还有一个 <code>time_for_children</code> 文件，它是 Time 命名空间的“子进程专用版”：</p>
<ul>
<li><code>time</code>：控制当前进程自身的时间视图；</li>
<li><code>time_for_children</code>：控制当前进程创建的子进程的时间视图（子进程会继承这个命名空间）。</li>
</ul>
<p>这种设计允许更精细的时间隔离——例如，让父进程保持与宿主机时间一致，而子进程使用独立的时间流，灵活适配复杂的容器内进程关系。</p>
<h2 id="命名空间——用户权限（user）"><a href="#命名空间——用户权限（user）" class="headerlink" title="命名空间——用户权限（user）"></a>命名空间——用户权限（user）</h2><p>用户命名空间（User Namespace）是 Linux 中专门用于<strong>隔离用户 ID（UID）和组 ID（GID）</strong> 的机制，其核心价值是实现“<strong>权限内外分离</strong>”——让进程在命名空间“内部”拥有的权限（如 root 管理员权限），与在命名空间“外部”（主机系统）的实际权限完全独立，从底层支撑了“无根容器”等安全部署方案。</p>
<h3 id="什么是用户命名空间？"><a href="#什么是用户命名空间？" class="headerlink" title="什么是用户命名空间？"></a>什么是用户命名空间？</h3><p>用户命名空间的本质是“<strong>UID&#x2F;GID 身份映射</strong>”：打破传统 Linux 中 UID&#x2F;GID 全局唯一的规则，让同一个进程在不同命名空间中呈现不同的身份和权限。</p>
<ul>
<li>没有用户命名空间时：主机上的 <code>UID=0</code>（root）是全局最高权限，任何进程只要 UID&#x3D;0，就能操作主机所有资源；</li>
<li>有用户命名空间时：一个进程可以在<strong>命名空间内部</strong>是 <code>UID=0</code>（看起来是 root，能修改命名空间内的配置），但在<strong>命名空间外部</strong>（主机），它可能只是普通用户（如 <code>UID=1000</code>，没有主机的 root 权限）。</li>
</ul>
<p>简单说：用户命名空间让进程“在自己的隔离环境里当管理员，在主机系统里做普通人”，既满足应用对高权限的需求，又避免主机安全风险。</p>
<h3 id="用户命名空间的核心功能：UID-GID-映射与权限隔离"><a href="#用户命名空间的核心功能：UID-GID-映射与权限隔离" class="headerlink" title="用户命名空间的核心功能：UID&#x2F;GID 映射与权限隔离"></a>用户命名空间的核心功能：UID&#x2F;GID 映射与权限隔离</h3><h4 id="1-隔离的核心：内外身份映射（uid-map-与-gid-map）"><a href="#1-隔离的核心：内外身份映射（uid-map-与-gid-map）" class="headerlink" title="1. 隔离的核心：内外身份映射（uid_map 与 gid_map）"></a>1. 隔离的核心：内外身份映射（<code>uid_map</code> 与 <code>gid_map</code>）</h4><p>用户命名空间通过“映射文件”记录命名空间“内部 ID”与主机“外部 ID”的对应关系，这些文件位于 <code>/proc/[进程PID]/uid_map</code>（用户 ID 映射）和 <code>/proc/[进程PID]/gid_map</code>（组 ID 映射）。</p>
<p><strong>映射文件格式</strong>：每行包含三个参数，格式为 <code>内部ID 外部ID 长度</code>，含义如下：</p>
<ul>
<li><strong>内部ID</strong>：命名空间内进程看到的 UID&#x2F;GID（如容器内的 <code>UID=0</code>）；</li>
<li><strong>外部ID</strong>：主机系统中实际的 UID&#x2F;GID（如主机的 <code>UID=1000</code>）；</li>
<li><strong>长度</strong>：连续映射的 ID 数量（如“长度&#x3D;1”表示仅映射这一个 ID，“长度&#x3D;5”表示从内部ID开始，连续5个ID对应主机从外部ID开始的5个ID）。</li>
</ul>
<p><strong>示例</strong>：<br>若某进程的 <code>uid_map</code> 文件内容为 <code>0 1000 1</code>，表示：</p>
<ul>
<li>命名空间内的 <code>UID=0</code>（root），映射到主机的 <code>UID=1000</code>（普通用户 <code>kevin</code>）；</li>
<li>此时进程在命名空间内执行 <code>id -u</code> 显示 <code>0</code>（以为自己是 root），但在主机上用 <code>ps aux</code> 查看，其真实 UID 是 <code>1000</code>。</li>
</ul>
<h4 id="2-权限检查逻辑：映射如何生效？"><a href="#2-权限检查逻辑：映射如何生效？" class="headerlink" title="2. 权限检查逻辑：映射如何生效？"></a>2. 权限检查逻辑：映射如何生效？</h4><p>当命名空间内的进程操作资源（如读写文件、修改配置）时，内核会自动进行“身份转换”来判断权限，流程如下：</p>
<ol>
<li><strong>进程操作资源时</strong>：内核将进程的“内部 UID&#x2F;GID”通过 <code>uid_map</code>&#x2F;<code>gid_map</code> 转换为“外部 UID&#x2F;GID”，再用外部 ID 检查主机上的资源权限；<ul>
<li>例：内部 <code>UID=0</code> 映射到外部 <code>UID=1000</code>，进程尝试修改主机上属于 <code>UID=1000</code> 的文件（如 <code>/home/kevin/test.txt</code>），会被允许；但尝试修改主机 root 专属文件（如 <code>/etc/passwd</code>），会因外部 ID 无权限而被拒绝。</li>
</ul>
</li>
<li><strong>进程查询资源属性时</strong>：内核做“反向映射”——将主机资源的外部 ID 转换为内部 ID 后返回；<ul>
<li>例：主机上属于 <code>UID=1000</code> 的文件，在命名空间内会被显示为 <code>UID=0</code>，让进程误以为这是“自己的文件”。</li>
</ul>
</li>
</ol>
<h4 id="3-未映射-ID-的处理：溢出用户（nobody）"><a href="#3-未映射-ID-的处理：溢出用户（nobody）" class="headerlink" title="3. 未映射 ID 的处理：溢出用户（nobody）"></a>3. 未映射 ID 的处理：溢出用户（nobody）</h4><p>若进程的内部 UID&#x2F;GID 未在映射文件中定义（如刚创建命名空间未配置映射），内核会自动将其转换为“溢出 ID”：</p>
<ul>
<li>溢出 UID&#x2F;GID 默认为 <code>65534</code>，对应系统用户 <code>nobody</code> 和组 <code>nogroup</code>，仅拥有最低权限；</li>
<li>示例：未配置映射时进入用户命名空间，执行 <code>id -u</code> 会显示 <code>65534</code>，无法进行任何高权限操作。</li>
</ul>
<h4 id="4-安全控制：setgroups-文件"><a href="#4-安全控制：setgroups-文件" class="headerlink" title="4. 安全控制：setgroups 文件"></a>4. 安全控制：<code>setgroups</code> 文件</h4><p><code>/proc/[PID]/setgroups</code> 文件用于限制命名空间内是否允许修改“附加组列表”（通过 <code>setgroups()</code> 系统调用），仅两种取值：</p>
<ul>
<li><code>deny</code>（默认）：禁止调用 <code>setgroups()</code>，防止非特权用户通过修改组权限越权；</li>
<li><code>allow</code>：允许调用（需主机特殊权限），通常用于需要灵活管理组权限的场景。<br>该限制是为了避免用户命名空间被滥用——若允许随意修改组列表，可能绕过主机的权限隔离。</li>
</ul>
<h4 id="5-实际操作：sudo-unshare-U-做了什么？"><a href="#5-实际操作：sudo-unshare-U-做了什么？" class="headerlink" title="5. 实际操作：sudo unshare -U 做了什么？"></a>5. 实际操作：<code>sudo unshare -U</code> 做了什么？</h4><p><code>sudo unshare -U</code> 命令的作用是<strong>创建新的用户命名空间并进入</strong>（<code>-U</code> 是 <code>--user</code> 的缩写），通过步骤可直观看到隔离效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1：在主机（默认命名空间）查看当前用户 UID（假设为 1000）</span></span><br><span class="line"><span class="built_in">id</span> -u  <span class="comment"># 输出：1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2：创建新用户命名空间并进入（未配置映射，默认用溢出 ID）</span></span><br><span class="line"><span class="built_in">sudo</span> unshare -U /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3：在新命名空间查看 UID（未映射，显示溢出 ID）</span></span><br><span class="line"><span class="built_in">id</span> -u  <span class="comment"># 输出：65534（nobody）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4：配置映射（将内部 UID=0 映射到主机 UID=1000，需 root 权限）</span></span><br><span class="line"><span class="comment"># 先允许写入映射文件（仅演示，实际需严格权限控制）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;0 1000 1&quot;</span> &gt; /proc/$$/uid_map  <span class="comment"># $$ 表示当前 bash 进程的 PID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤5：重新查看 UID（已映射为内部 root）</span></span><br><span class="line"><span class="built_in">id</span> -u  <span class="comment"># 输出：0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤6：尝试修改主机 root 文件（如 /etc/passwd），会被拒绝（外部 ID 无权限）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> &gt;&gt; /etc/passwd  <span class="comment"># 输出：Permission denied</span></span><br></pre></td></tr></table></figure>

<p><strong>核心效果</strong>：命名空间内的“root”仅能操作映射范围内的资源，无法越权影响主机。</p>
<h3 id="为什么用户命名空间对容器至关重要？"><a href="#为什么用户命名空间对容器至关重要？" class="headerlink" title="为什么用户命名空间对容器至关重要？"></a>为什么用户命名空间对容器至关重要？</h3><p>用户命名空间是“无根容器”（Rootless Container）的核心技术，解决了传统容器的安全痛点：</p>
<ul>
<li>传统容器：需要主机 root 权限才能创建（如操作网络、挂载文件系统），一旦容器被攻破，攻击者可能获得主机 root 权限；</li>
<li>无根容器：普通用户可创建用户命名空间，在其中映射自己为内部 root，结合 PID、mount 等命名空间构建完整容器环境；<ul>
<li>容器内的 root 操作被映射为宿主普通用户权限，即使容器逃逸，也无法获取主机 root 权限，大幅降低安全风险。</li>
</ul>
</li>
</ul>
<p>现在主流容器工具（如 Docker、Podman）均支持无根模式，其底层依赖的正是用户命名空间的 UID&#x2F;GID 映射能力。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>用户命名空间的核心是“<strong>身份映射+权限隔离</strong>”，实现了“内部高权限、外部低权限”的安全模型：</p>
<ul>
<li>对应用：在命名空间内获得 root 权限，满足部署和运行需求；</li>
<li>对主机：进程真实权限被限制为普通用户，避免安全风险；</li>
<li>对容器：支撑无根容器普及，是容器安全的关键底层技术。</li>
</ul>
<h2 id="命名空间——资源控制（cgroup）"><a href="#命名空间——资源控制（cgroup）" class="headerlink" title="命名空间——资源控制（cgroup）"></a>命名空间——资源控制（cgroup）</h2><p>cgroup（Control Groups，控制组）是 Linux 内核提供的<strong>进程资源管理机制</strong>，核心作用是给进程（或进程组）“划定资源使用边界”——通过限制、监控和分配 CPU、内存、磁盘 I&#x2F;O 等硬件资源，避免单个进程过度占用资源导致系统卡顿或崩溃，是容器技术中“资源可控”的底层核心支撑。</p>
<h3 id="什么是-cgroup？"><a href="#什么是-cgroup？" class="headerlink" title="什么是 cgroup？"></a>什么是 cgroup？</h3><p>cgroup 的本质是“<strong>按组管理进程资源</strong>”：将多个进程归类到同一个“控制组”，通过统一配置该组的资源规则，实现对所有进程的批量资源管控。它与命名空间的核心区别在于：  </p>
<ul>
<li><strong>命名空间</strong>：负责“隔离资源视图”——让进程看不到其他命名空间的资源（如网络、文件系统），实现“各过各的”；  </li>
<li><strong>cgroup</strong>：负责“控制资源用量”——限制进程能使用的资源上限（如最多用 1GB 内存、50% CPU），实现“别太过分”。</li>
</ul>
<p>简单说：如果把命名空间比作“独立房间”，让进程在自己的房间里看不到外界；cgroup 就是“房间里的水电表”，限制每个房间的水电用量，避免某间房过度消耗导致整栋楼断水断电。</p>
<h3 id="cgroup-的核心功能"><a href="#cgroup-的核心功能" class="headerlink" title="cgroup 的核心功能"></a>cgroup 的核心功能</h3><p>cgroup 对资源的管理支持的资源类型覆盖 CPU、内存、磁盘 I&#x2F;O、网络等，以下是最常用的资源及功能：</p>
<table>
<thead>
<tr>
<th>资源类型</th>
<th>核心管控能力</th>
<th>通俗理解</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>1. 限制 CPU 使用率（如最多用 50%）；<br>2. 绑定进程到特定 CPU 核心（如只能用核心 2、3）；<br>3. 设置 CPU 优先级（如重要进程优先占用 CPU）</td>
<td>给进程“分配 CPU 使用时间配额”，避免某进程霸占核心</td>
</tr>
<tr>
<td>内存</td>
<td>1. 限制最大物理内存使用（如最多用 1GB）；<br>2. 限制交换分区使用（如禁止用交换分区）；<br>3. 内存超限时触发 OOM（杀死进程）</td>
<td>给进程“设定内存使用上限”，防止内存溢出拖垮系统</td>
</tr>
<tr>
<td>磁盘 I&#x2F;O</td>
<td>1. 限制磁盘读写速率（如写速度不超过 100MB&#x2F;s）；<br>2. 限制磁盘 I&#x2F;O 优先级（如数据库进程优先读写磁盘）</td>
<td>给进程“限制磁盘读写速度”，避免某进程占满磁盘带宽</td>
</tr>
</tbody></table>
<blockquote>
<p>本篇对cgroup仅仅做概述，cgroup内容很多，详细内容参考下讲。</p>
</blockquote>
<h3 id="为什么-cgroup-对容器很重要？"><a href="#为什么-cgroup-对容器很重要？" class="headerlink" title="为什么 cgroup 对容器很重要？"></a>为什么 cgroup 对容器很重要？</h3><p>容器的核心需求之一是“资源可控”——用户需要明确限制容器能使用的 CPU、内存等资源（如“这个 Nginx 容器最多用 2GB 内存、1 个 CPU 核心”），而这些需求的底层实现全依赖 cgroup：</p>
<ul>
<li>当你用 Docker 执行 <code>docker run --memory 1GB --cpus 0.5 nginx</code> 时，Docker 本质是在 <code>/sys/fs/cgroup</code> 下创建对应的控制组，将 <code>memory.limit_in_bytes</code> 设为 1GB、<code>cpu.cfs_quota_us</code> 设为 50000（对应 0.5 个 CPU），再将容器进程加入该控制组；</li>
<li>若没有 cgroup，容器可能无限制占用主机资源（如一个异常容器占满所有 CPU），导致主机及其他容器崩溃。</li>
</ul>
<p>可以说，cgroup 是容器从“能隔离”到“能可控”的关键——让容器不仅“看起来像独立系统”，更“用起来不影响别人”。</p>
<blockquote>
<p>cgroup既是namespace的一种，又是独立的技术（资源管理机制），<strong>cgroup 资源管理机制负责 “控制资源用量”，cgroup 命名空间负责 “隔离资源视图”</strong>，cgroup对容器来说至关重要，我们将在下一讲继续讨论cgroup。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/zmty365">爱吃芝麻汤圆</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zmty365.github.io/posts/1000101/">http://zmty365.github.io/posts/1000101/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://zmty365.github.io" target="_blank">爱吃芝麻汤圆</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Container/">Container</a><a class="post-meta__tags" href="/tags/Namespace/">Namespace</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>感谢您的支持！</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/1000100/" title="Container"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Container</div></div><div class="info-2"><div class="info-item-1">容器概述容器是什么 容器是一种受隔离（namespace）且受约束（cgroups）的进程组，也是隔离且受约束的环境，可在其中运行一个或多个进程。  容器技术底层容器的实现依赖于 Linux 内核提供的两个核心功能：Namespace 和 Cgroup。这些技术共同支撑了容器的隔离性和资源管理机制，此外，UnionFS（联合文件系统） 是实现镜像轻量化的关键。 1. Namespace：实现“视图隔离”作用是为容器提供独立的“系统视图”，让容器内进程误以为自己在独立的操作系统中运行，实现资源隔离。常见的 Namespace 类型及功能如下：    命名空间类型 作用（隔离的资源） 典型场景    PID（进程 ID） 隔离进程 ID 编号空间。每个命名空间内的进程有独立的 PID 序列（如各自的 PID&#x3D;1），且看不到其他命名空间的进程。 容器内的进程 PID 与主机隔离（如容器内的 init 进程为 PID&#x3D;1）。   Mount（挂载） 隔离文件系统挂载点。不同命名空间的进程看到的挂载点（文件系统结构）可以不同。 容器拥有独立的根文件系统（如 / 目录与主...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/1000100/" title="Container"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-21</div><div class="info-item-2">Container</div></div><div class="info-2"><div class="info-item-1">容器概述容器是什么 容器是一种受隔离（namespace）且受约束（cgroups）的进程组，也是隔离且受约束的环境，可在其中运行一个或多个进程。  容器技术底层容器的实现依赖于 Linux 内核提供的两个核心功能：Namespace 和 Cgroup。这些技术共同支撑了容器的隔离性和资源管理机制，此外，UnionFS（联合文件系统） 是实现镜像轻量化的关键。 1. Namespace：实现“视图隔离”作用是为容器提供独立的“系统视图”，让容器内进程误以为自己在独立的操作系统中运行，实现资源隔离。常见的 Namespace 类型及功能如下：    命名空间类型 作用（隔离的资源） 典型场景    PID（进程 ID） 隔离进程 ID 编号空间。每个命名空间内的进程有独立的 PID 序列（如各自的 PID&#x3D;1），且看不到其他命名空间的进程。 容器内的进程 PID 与主机隔离（如容器内的 init 进程为 PID&#x3D;1）。   Mount（挂载） 隔离文件系统挂载点。不同命名空间的进程看到的挂载点（文件系统结构）可以不同。 容器拥有独立的根文件系统（如 / 目录与主...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">爱吃芝麻汤圆</div><div class="author-info-description">事情开始变得有趣啦！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zmty365"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zmty365" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:huik47816@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.csdn.net/woshihlf" target="_blank" title="CSDN"><i class="fa-solid fa-code" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.</span> <span class="toc-text">Linux 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">命名空间概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%85%B3API"><span class="toc-number">1.2.</span> <span class="toc-text">命名空间相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-clone-%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9B%E7%A8%8B%E6%97%B6%E2%80%9C%E9%A1%BA%E5%B8%A6%E2%80%9D%E5%88%9B%E5%BB%BA%E6%96%B0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. clone()：创建新进程时“顺带”创建新命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">关键特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">举例说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-fork-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">与 fork() 的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-unshare-%EF%BC%9A%E8%AE%A9%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%E2%80%9C%E8%84%B1%E7%A6%BB%E2%80%9D%E5%85%B1%E4%BA%AB%EF%BC%8C%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. unshare()：让当前进程“脱离”共享，创建自己的命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">关键特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">举例说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%EF%BC%9Aunshare"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">对应命令工具：unshare</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-setns-%EF%BC%9A%E8%AE%A9%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%E2%80%9C%E5%8A%A0%E5%85%A5%E2%80%9D%E5%B7%B2%E6%9C%89%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. setns()：让当前进程“加入”已有的命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">关键特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A-2"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">举例说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%EF%BC%9Ansenter"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">对应命令工具：nsenter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%89%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.4.</span> <span class="toc-text">总结：三个系统调用的核心区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E6%8C%82%E8%BD%BD-mnt"><span class="toc-number">1.3.</span> <span class="toc-text">命名空间——挂载 (mnt)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%8C%82%E8%BD%BD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建并使用挂载命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%9C%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%88%E7%AB%AF%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%96%87%E4%BB%B6%E7%9A%84-tmpfs%EF%BC%88%E6%96%B0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.3.1.0.1.</span> <span class="toc-text">步骤1：在第一个终端创建带文件的 tmpfs（新命名空间）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E5%9C%A8%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%BB%88%E7%AB%AF%E7%9B%B4%E6%8E%A5%E6%8C%82%E8%BD%BD-tmpfs-%E5%88%B0%E5%90%8C%E4%B8%80%E7%9B%AE%E5%BD%95%EF%BC%88%E5%8E%9F%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.3.1.0.2.</span> <span class="toc-text">步骤2：在第二个终端直接挂载 tmpfs 到同一目录（原命名空间）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E4%B8%8D%E5%88%B0%EF%BC%9F%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%9B%A0%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%BB%88%E7%AB%AF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8C%82%E8%BD%BD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.1.0.3.</span> <span class="toc-text">为什么看不到？核心原因：两个终端在不同的挂载命名空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BB%88%E7%AB%AF%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%89%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.3.1.0.4.</span> <span class="toc-text">如何让另一个终端看到这三个文件？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.1.0.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8BID%EF%BC%88pid%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">命名空间——进程ID（pid）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%8C%82%E8%BD%BD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">创建并使用挂载命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%96%B0PID%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%B9%B6%E9%87%8D%E6%96%B0%E6%8C%82%E8%BD%BD-proc"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">步骤1：创建新PID命名空间并重新挂载&#x2F;proc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E5%9C%A8%E6%96%B0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">步骤2：在新命名空间中创建子进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E5%9C%A8%E4%B8%BB%E6%9C%BA%E7%BB%88%E7%AB%AF%E6%9F%A5%E7%9C%8B%EF%BC%88%E5%85%A8%E5%B1%80%E8%A7%86%E8%A7%92%EF%BC%89"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">步骤3：在主机终端查看（全局视角）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sudo-unshare-fp-mount-proc-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">sudo unshare -fp --mount-proc 到底做了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-sudo%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1. sudo：获取权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-f%EF%BC%88-fork%EF%BC%89%EF%BC%9A%E5%AE%89%E5%85%A8%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2. -f（--fork）：安全创建新进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-p%EF%BC%88-pid%EF%BC%89%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84PID%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3. -p（--pid）：创建新的PID命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-mount-proc%EF%BC%9A%E9%87%8D%E6%96%B0%E6%8C%82%E8%BD%BD-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4. --mount-proc：重新挂载&#x2F;proc文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%EF%BC%88net%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">命名空间——网络（net）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9A%E5%BB%BA%E4%B8%80%E4%B8%AA%E2%80%9C%E6%96%B0%E6%88%BF%E9%97%B4%E2%80%9D"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">1. 创建网络命名空间：建一个“新房间”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9B%E5%85%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%93%8D%E4%BD%9C%EF%BC%9A%E2%80%9C%E8%B5%B0%E8%BF%9B%E6%88%BF%E9%97%B4%E2%80%9D"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">2. 进入命名空间操作：“走进房间”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%AF%E7%94%A8%E7%8E%AF%E5%9B%9E%E6%8E%A5%E5%8F%A3%EF%BC%9A%E2%80%9C%E6%8E%A5%E9%80%9A%E5%86%85%E9%83%A8%E7%94%B5%E8%AF%9D%E2%80%9D"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">3. 启用环回接口：“接通内部电话”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%9B%E5%BB%BA-veth-%E5%AF%B9%EF%BC%9A%E6%8B%89%E4%B8%80%E6%A0%B9%E2%80%9C%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BA%BF%E2%80%9D"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">4. 创建 veth 对：拉一根“虚拟网线”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BF%9E%E6%8E%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%8A%8A%E7%BD%91%E7%BA%BF%E2%80%9C%E6%8F%92%E8%BF%9B%E6%88%BF%E9%97%B4%E2%80%9D"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">5. 连接命名空间：把网线“插进房间”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%85%8D%E7%BD%AE-IP-%E5%9C%B0%E5%9D%80%EF%BC%9A%E7%BB%99%E2%80%9C%E7%BD%91%E7%BA%BF%E6%8E%A5%E5%8F%A3%E2%80%9D%E5%88%86%E9%85%8D%E9%97%A8%E7%89%8C%E5%8F%B7"><span class="toc-number">1.5.0.6.</span> <span class="toc-text">6. 配置 IP 地址：给“网线接口”分配门牌号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%B5%8B%E8%AF%95%E9%80%9A%E4%BF%A1%EF%BC%9A%E4%B8%A4%E4%B8%AA%E2%80%9C%E6%88%BF%E9%97%B4%E2%80%9D%E8%83%BD%E9%80%9A%E8%AF%9D%E4%BA%86"><span class="toc-number">1.5.0.7.</span> <span class="toc-text">7. 测试通信：两个“房间”能通话了</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E4%BA%92%E8%81%94%E7%BD%91%EF%BC%9F"><span class="toc-number">1.5.0.8.</span> <span class="toc-text">8. 为什么访问不了互联网？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88ipc%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">命名空间——进程间通信（ipc）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-IPC%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是 IPC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-IPC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">为什么需要 IPC 命名空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9A%94%E7%A6%BB-IPC-%E8%B5%84%E6%BA%90"><span class="toc-number">1.6.3.</span> <span class="toc-text">IPC 命名空间的核心功能：隔离 IPC 资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9A%94%E7%A6%BB%E7%9A%84%E5%85%B7%E4%BD%93%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1. 隔离的具体对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E9%9A%94%E7%A6%BB"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2. 举例说明：共享内存的隔离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B8%85%E7%90%86"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3. 命名空间销毁时的自动清理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB"><span class="toc-number">1.6.4.</span> <span class="toc-text">IPC 命名空间的典型应用：容器的安全隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94UNIX-%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F-uts"><span class="toc-number">1.7.</span> <span class="toc-text">命名空间——UNIX 分时系统 (uts)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-UTS%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">什么是 UTS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UTS-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9A%94%E7%A6%BB%E4%B8%BB%E6%9C%BA%E6%A0%87%E8%AF%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">UTS 命名空间的核心功能：隔离主机标识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">1. 隔离的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%EF%BC%9Asudo-unshare-u-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">2. 实际操作：sudo unshare -u 做了什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-UTS-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AF%B9%E5%AE%B9%E5%99%A8%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">为什么 UTS 命名空间对容器很重要？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4-time"><span class="toc-number">1.8.</span> <span class="toc-text">命名空间——时间 (time)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Time-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">什么是 Time 命名空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Time-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.8.2.</span> <span class="toc-text">Time 命名空间的核心功能：隔离系统时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">1. 隔离的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%EF%BC%9Asudo-unshare-T-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2. 实际操作：sudo unshare -T 做了什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%AF%B4%E6%98%8E%EF%BC%9Atime-for-children-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">特殊说明：time_for_children 的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%EF%BC%88user%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">命名空间——用户权限（user）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">什么是用户命名空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9AUID-GID-%E6%98%A0%E5%B0%84%E4%B8%8E%E6%9D%83%E9%99%90%E9%9A%94%E7%A6%BB"><span class="toc-number">1.9.2.</span> <span class="toc-text">用户命名空间的核心功能：UID&#x2F;GID 映射与权限隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9A%94%E7%A6%BB%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9A%E5%86%85%E5%A4%96%E8%BA%AB%E4%BB%BD%E6%98%A0%E5%B0%84%EF%BC%88uid-map-%E4%B8%8E-gid-map%EF%BC%89"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">1. 隔离的核心：内外身份映射（uid_map 与 gid_map）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5%E9%80%BB%E8%BE%91%EF%BC%9A%E6%98%A0%E5%B0%84%E5%A6%82%E4%BD%95%E7%94%9F%E6%95%88%EF%BC%9F"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">2. 权限检查逻辑：映射如何生效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%AA%E6%98%A0%E5%B0%84-ID-%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%9A%E6%BA%A2%E5%87%BA%E7%94%A8%E6%88%B7%EF%BC%88nobody%EF%BC%89"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">3. 未映射 ID 的处理：溢出用户（nobody）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6%EF%BC%9Asetgroups-%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">4. 安全控制：setgroups 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%EF%BC%9Asudo-unshare-U-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.9.2.5.</span> <span class="toc-text">5. 实际操作：sudo unshare -U 做了什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AF%B9%E5%AE%B9%E5%99%A8%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">1.9.3.</span> <span class="toc-text">为什么用户命名空间对容器至关重要？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">1.9.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%EF%BC%88cgroup%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">命名空间——资源控制（cgroup）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-cgroup%EF%BC%9F"><span class="toc-number">1.10.1.</span> <span class="toc-text">什么是 cgroup？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cgroup-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">1.10.2.</span> <span class="toc-text">cgroup 的核心功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-cgroup-%E5%AF%B9%E5%AE%B9%E5%99%A8%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">1.10.3.</span> <span class="toc-text">为什么 cgroup 对容器很重要？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1000101/" title="Namespace">Namespace</a><time datetime="2025-08-21T03:52:48.000Z" title="发表于 2025-08-21 11:52:48">2025-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1000100/" title="Container">Container</a><time datetime="2025-08-21T03:50:24.000Z" title="发表于 2025-08-21 11:50:24">2025-08-21</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"></div><div class="footer_custom_text"><style>
  .footer {
    text-align: center;
    position: relative;
  }
  .social-links {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    flex-wrap: wrap;
  }
  .social-links i {
    color: #fafafa;
  }
  .social-link {
    color: #fafafa;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    background: rgba(138, 43, 226, 0.1);
  }
  .social-link:hover {
    color: #fafafa;
    background: #fafafa;
    transform: translateY(-3px) scale(1.2);
    box-shadow: 0 5px 15px rgba(138, 43, 226, 0.4);
    text-decoration: none !important; 
  }
  .footer p {
    margin: 0.5rem 0;
    line-height: 1;
  }
  .copyright {
    font-size: 1.15rem; 
    color: #fafafa;
    font-weight: 400;
  }
  .visitor-count {
    font-size: 0.9rem;
    color: #fafafa;
    font-weight: 300;
  }
  #visitorCount {
    font-weight: bold;
  }
</style>
<div class="footer">
  <div class="social-links">
    <a href="https://github.com/zmty365" class="social-link" target="_blank" rel="noopener noreferrer" aria-label="GitHub" title="GitHub">
      <i class="fab fa-github"></i>
    </a>
    <a href="https://blog.csdn.net/woshihlf" class="social-link" target="_blank" rel="noopener noreferrer" aria-label="CSDN" title="CSDN">
      <i class="fas fa-code"></i>
    </a>
  </div>
  <p class="copyright">© 2025 爱吃芝麻汤圆 - 所有权利保留</p>
  <p class="visitor-count">访问量: <span id="visitorCount">1024</span> | 你是第 <span id="dailyVisitor">1</span> 位今日访客</p>
</div>
<script>
  // 确保DOM加载完成后执行
  document.addEventListener('DOMContentLoaded', function() {
    // 模拟访问量增长
    function updateVisitorCount() {
      const countElement = document.getElementById('visitorCount');
      let count = parseInt(countElement.textContent) || 1024;
      // 从localStorage获取或初始化计数
      const storedCount = localStorage.getItem('totalVisitors');
      if (storedCount) {
        count = parseInt(storedCount);
        countElement.textContent = count;
      }
      // 每日访客计数
      const today = new Date().toDateString();
      const dailyData = JSON.parse(localStorage.getItem('dailyVisitors') || '{"date":"", "count":0}');
      if (dailyData.date !== today) {
        dailyData.date = today;
        dailyData.count = 0;
      }
      dailyData.count += 1;
      document.getElementById('dailyVisitor').textContent = dailyData.count;
      localStorage.setItem('dailyVisitors', JSON.stringify(dailyData));
      // 每30秒随机增加访问量
      setInterval(() => {
        count += Math.floor(Math.random() * 3);
        countElement.textContent = count;
        localStorage.setItem('totalVisitors', count.toString());
      }, 30000);
    }
    updateVisitorCount();
    // 添加点击动画效果
    const socialLinks = document.querySelectorAll('.social-link');
    socialLinks.forEach(link => {
      link.addEventListener('click', function() {
        this.style.transform = 'scale(0.9)';
        setTimeout(() => {
          this.style.transform = '';
        }, 300);
      });
    });
  });
</script>
</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/true"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'bad752caa26a61016d03fdf399c1db5a'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Valine' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/js/sakura.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>